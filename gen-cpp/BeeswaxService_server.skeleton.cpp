// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "BeeswaxService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::beeswax;

class BeeswaxServiceHandler : virtual public BeeswaxServiceIf {
 public:
  BeeswaxServiceHandler() {
    // Your initialization goes here
  }

  /**
   * Submit a query and return a handle (QueryHandle). The query runs asynchronously.
   * 
   * @param query
   */
  void query(QueryHandle& _return, const Query& query) {
    // Your implementation goes here
    printf("query\n");
  }

  /**
   * run a query synchronously and return a handle (QueryHandle).
   * 
   * @param query
   * @param clientCtx
   */
  void executeAndWait(QueryHandle& _return, const Query& query, const LogContextId& clientCtx) {
    // Your implementation goes here
    printf("executeAndWait\n");
  }

  /**
   * Get the query plan for a query.
   * 
   * @param query
   */
  void explain(QueryExplanation& _return, const Query& query) {
    // Your implementation goes here
    printf("explain\n");
  }

  /**
   * Get the results of a query. This is non-blocking. Caller should check
   * Results.ready to determine if the results are in yet. The call requests
   * the batch size of fetch.
   * 
   * @param query_id
   * @param start_over
   * @param fetch_size
   */
  void fetch(Results& _return, const QueryHandle& query_id, const bool start_over, const int32_t fetch_size) {
    // Your implementation goes here
    printf("fetch\n");
  }

  /**
   * Get the state of the query
   * 
   * @param handle
   */
  QueryState::type get_state(const QueryHandle& handle) {
    // Your implementation goes here
    printf("get_state\n");
  }

  /**
   * Get the result metadata
   * 
   * @param handle
   */
  void get_results_metadata(ResultsMetadata& _return, const QueryHandle& handle) {
    // Your implementation goes here
    printf("get_results_metadata\n");
  }

  /**
   * Used to test connection to server.  A "noop" command.
   * 
   * @param s
   */
  void echo(std::string& _return, const std::string& s) {
    // Your implementation goes here
    printf("echo\n");
  }

  /**
   * Returns a string representation of the configuration object being used.
   * Handy for debugging.
   */
  void dump_config(std::string& _return) {
    // Your implementation goes here
    printf("dump_config\n");
  }

  /**
   * Get the log messages related to the given context.
   * 
   * @param context
   */
  void get_log(std::string& _return, const LogContextId& context) {
    // Your implementation goes here
    printf("get_log\n");
  }

  void get_default_configuration(std::vector<ConfigVariable> & _return, const bool include_hadoop) {
    // Your implementation goes here
    printf("get_default_configuration\n");
  }

  void close(const QueryHandle& handle) {
    // Your implementation goes here
    printf("close\n");
  }

  void clean(const LogContextId& log_context) {
    // Your implementation goes here
    printf("clean\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<BeeswaxServiceHandler> handler(new BeeswaxServiceHandler());
  shared_ptr<TProcessor> processor(new BeeswaxServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

