/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ExecStats_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kTExecStateValues[] = {
  TExecState::REGISTERED,
  TExecState::PLANNING,
  TExecState::QUEUED,
  TExecState::RUNNING,
  TExecState::FINISHED,
  TExecState::CANCELLED,
  TExecState::FAILED
};
const char* _kTExecStateNames[] = {
  "REGISTERED",
  "PLANNING",
  "QUEUED",
  "RUNNING",
  "FINISHED",
  "CANCELLED",
  "FAILED"
};
const std::map<int, const char*> _TExecState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTExecStateValues, _kTExecStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TExecStats::~TExecStats() throw() {
}


void TExecStats::__set_latency_ns(const int64_t val) {
  this->latency_ns = val;
__isset.latency_ns = true;
}

void TExecStats::__set_cpu_time_ns(const int64_t val) {
  this->cpu_time_ns = val;
__isset.cpu_time_ns = true;
}

void TExecStats::__set_cardinality(const int64_t val) {
  this->cardinality = val;
__isset.cardinality = true;
}

void TExecStats::__set_memory_used(const int64_t val) {
  this->memory_used = val;
__isset.memory_used = true;
}

uint32_t TExecStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latency_ns);
          this->__isset.latency_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_time_ns);
          this->__isset.cpu_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cardinality);
          this->__isset.cardinality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory_used);
          this->__isset.memory_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TExecStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecStats");

  if (this->__isset.latency_ns) {
    xfer += oprot->writeFieldBegin("latency_ns", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->latency_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cpu_time_ns) {
    xfer += oprot->writeFieldBegin("cpu_time_ns", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->cpu_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cardinality) {
    xfer += oprot->writeFieldBegin("cardinality", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->cardinality);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memory_used) {
    xfer += oprot->writeFieldBegin("memory_used", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->memory_used);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecStats &a, TExecStats &b) {
  using ::std::swap;
  swap(a.latency_ns, b.latency_ns);
  swap(a.cpu_time_ns, b.cpu_time_ns);
  swap(a.cardinality, b.cardinality);
  swap(a.memory_used, b.memory_used);
  swap(a.__isset, b.__isset);
}

TExecStats::TExecStats(const TExecStats& other0) {
  latency_ns = other0.latency_ns;
  cpu_time_ns = other0.cpu_time_ns;
  cardinality = other0.cardinality;
  memory_used = other0.memory_used;
  __isset = other0.__isset;
}
TExecStats& TExecStats::operator=(const TExecStats& other1) {
  latency_ns = other1.latency_ns;
  cpu_time_ns = other1.cpu_time_ns;
  cardinality = other1.cardinality;
  memory_used = other1.memory_used;
  __isset = other1.__isset;
  return *this;
}
void TExecStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecStats(";
  out << "latency_ns="; (__isset.latency_ns ? (out << to_string(latency_ns)) : (out << "<null>"));
  out << ", " << "cpu_time_ns="; (__isset.cpu_time_ns ? (out << to_string(cpu_time_ns)) : (out << "<null>"));
  out << ", " << "cardinality="; (__isset.cardinality ? (out << to_string(cardinality)) : (out << "<null>"));
  out << ", " << "memory_used="; (__isset.memory_used ? (out << to_string(memory_used)) : (out << "<null>"));
  out << ")";
}


TPlanNodeExecSummary::~TPlanNodeExecSummary() throw() {
}


void TPlanNodeExecSummary::__set_node_id(const  ::impala::TPlanNodeId val) {
  this->node_id = val;
}

void TPlanNodeExecSummary::__set_fragment_id(const int32_t val) {
  this->fragment_id = val;
}

void TPlanNodeExecSummary::__set_label(const std::string& val) {
  this->label = val;
}

void TPlanNodeExecSummary::__set_label_detail(const std::string& val) {
  this->label_detail = val;
__isset.label_detail = true;
}

void TPlanNodeExecSummary::__set_num_children(const int32_t val) {
  this->num_children = val;
}

void TPlanNodeExecSummary::__set_estimated_stats(const TExecStats& val) {
  this->estimated_stats = val;
__isset.estimated_stats = true;
}

void TPlanNodeExecSummary::__set_exec_stats(const std::vector<TExecStats> & val) {
  this->exec_stats = val;
__isset.exec_stats = true;
}

void TPlanNodeExecSummary::__set_is_active(const std::vector<bool> & val) {
  this->is_active = val;
__isset.is_active = true;
}

void TPlanNodeExecSummary::__set_is_broadcast(const bool val) {
  this->is_broadcast = val;
__isset.is_broadcast = true;
}

uint32_t TPlanNodeExecSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_fragment_id = false;
  bool isset_label = false;
  bool isset_num_children = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fragment_id);
          isset_fragment_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          isset_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label_detail);
          this->__isset.label_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->estimated_stats.read(iprot);
          this->__isset.estimated_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exec_stats.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->exec_stats.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->exec_stats[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exec_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_active.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->is_active.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += iprot->readBool(this->is_active[_i11]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_broadcast);
          this->__isset.is_broadcast = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanNodeExecSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanNodeExecSummary");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->fragment_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->label);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.label_detail) {
    xfer += oprot->writeFieldBegin("label_detail", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->label_detail);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.estimated_stats) {
    xfer += oprot->writeFieldBegin("estimated_stats", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->estimated_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exec_stats) {
    xfer += oprot->writeFieldBegin("exec_stats", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exec_stats.size()));
      std::vector<TExecStats> ::const_iterator _iter12;
      for (_iter12 = this->exec_stats.begin(); _iter12 != this->exec_stats.end(); ++_iter12)
      {
        xfer += (*_iter12).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_active.size()));
      std::vector<bool> ::const_iterator _iter13;
      for (_iter13 = this->is_active.begin(); _iter13 != this->is_active.end(); ++_iter13)
      {
        xfer += oprot->writeBool((*_iter13));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_broadcast) {
    xfer += oprot->writeFieldBegin("is_broadcast", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_broadcast);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanNodeExecSummary &a, TPlanNodeExecSummary &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.fragment_id, b.fragment_id);
  swap(a.label, b.label);
  swap(a.label_detail, b.label_detail);
  swap(a.num_children, b.num_children);
  swap(a.estimated_stats, b.estimated_stats);
  swap(a.exec_stats, b.exec_stats);
  swap(a.is_active, b.is_active);
  swap(a.is_broadcast, b.is_broadcast);
  swap(a.__isset, b.__isset);
}

TPlanNodeExecSummary::TPlanNodeExecSummary(const TPlanNodeExecSummary& other14) {
  node_id = other14.node_id;
  fragment_id = other14.fragment_id;
  label = other14.label;
  label_detail = other14.label_detail;
  num_children = other14.num_children;
  estimated_stats = other14.estimated_stats;
  exec_stats = other14.exec_stats;
  is_active = other14.is_active;
  is_broadcast = other14.is_broadcast;
  __isset = other14.__isset;
}
TPlanNodeExecSummary& TPlanNodeExecSummary::operator=(const TPlanNodeExecSummary& other15) {
  node_id = other15.node_id;
  fragment_id = other15.fragment_id;
  label = other15.label;
  label_detail = other15.label_detail;
  num_children = other15.num_children;
  estimated_stats = other15.estimated_stats;
  exec_stats = other15.exec_stats;
  is_active = other15.is_active;
  is_broadcast = other15.is_broadcast;
  __isset = other15.__isset;
  return *this;
}
void TPlanNodeExecSummary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanNodeExecSummary(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "fragment_id=" << to_string(fragment_id);
  out << ", " << "label=" << to_string(label);
  out << ", " << "label_detail="; (__isset.label_detail ? (out << to_string(label_detail)) : (out << "<null>"));
  out << ", " << "num_children=" << to_string(num_children);
  out << ", " << "estimated_stats="; (__isset.estimated_stats ? (out << to_string(estimated_stats)) : (out << "<null>"));
  out << ", " << "exec_stats="; (__isset.exec_stats ? (out << to_string(exec_stats)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "is_broadcast="; (__isset.is_broadcast ? (out << to_string(is_broadcast)) : (out << "<null>"));
  out << ")";
}


TExecProgress::~TExecProgress() throw() {
}


void TExecProgress::__set_total_scan_ranges(const int64_t val) {
  this->total_scan_ranges = val;
__isset.total_scan_ranges = true;
}

void TExecProgress::__set_num_completed_scan_ranges(const int64_t val) {
  this->num_completed_scan_ranges = val;
__isset.num_completed_scan_ranges = true;
}

uint32_t TExecProgress::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_scan_ranges);
          this->__isset.total_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_completed_scan_ranges);
          this->__isset.num_completed_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TExecProgress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecProgress");

  if (this->__isset.total_scan_ranges) {
    xfer += oprot->writeFieldBegin("total_scan_ranges", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->total_scan_ranges);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_completed_scan_ranges) {
    xfer += oprot->writeFieldBegin("num_completed_scan_ranges", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->num_completed_scan_ranges);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecProgress &a, TExecProgress &b) {
  using ::std::swap;
  swap(a.total_scan_ranges, b.total_scan_ranges);
  swap(a.num_completed_scan_ranges, b.num_completed_scan_ranges);
  swap(a.__isset, b.__isset);
}

TExecProgress::TExecProgress(const TExecProgress& other16) {
  total_scan_ranges = other16.total_scan_ranges;
  num_completed_scan_ranges = other16.num_completed_scan_ranges;
  __isset = other16.__isset;
}
TExecProgress& TExecProgress::operator=(const TExecProgress& other17) {
  total_scan_ranges = other17.total_scan_ranges;
  num_completed_scan_ranges = other17.num_completed_scan_ranges;
  __isset = other17.__isset;
  return *this;
}
void TExecProgress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecProgress(";
  out << "total_scan_ranges="; (__isset.total_scan_ranges ? (out << to_string(total_scan_ranges)) : (out << "<null>"));
  out << ", " << "num_completed_scan_ranges="; (__isset.num_completed_scan_ranges ? (out << to_string(num_completed_scan_ranges)) : (out << "<null>"));
  out << ")";
}


TExecSummary::~TExecSummary() throw() {
}


void TExecSummary::__set_state(const TExecState::type val) {
  this->state = val;
}

void TExecSummary::__set_status(const  ::impala::TStatus& val) {
  this->status = val;
__isset.status = true;
}

void TExecSummary::__set_nodes(const std::vector<TPlanNodeExecSummary> & val) {
  this->nodes = val;
__isset.nodes = true;
}

void TExecSummary::__set_exch_to_sender_map(const std::map<int32_t, int32_t> & val) {
  this->exch_to_sender_map = val;
__isset.exch_to_sender_map = true;
}

void TExecSummary::__set_error_logs(const std::vector<std::string> & val) {
  this->error_logs = val;
__isset.error_logs = true;
}

void TExecSummary::__set_progress(const TExecProgress& val) {
  this->progress = val;
__isset.progress = true;
}

uint32_t TExecSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->state = (TExecState::type)ecast18;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->nodes.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->nodes[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->exch_to_sender_map.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            xfer += iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              int32_t _key29;
              xfer += iprot->readI32(_key29);
              int32_t& _val30 = this->exch_to_sender_map[_key29];
              xfer += iprot->readI32(_val30);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.exch_to_sender_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->error_logs.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->error_logs.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += iprot->readString(this->error_logs[_i35]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.error_logs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->progress.read(iprot);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecSummary");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nodes) {
    xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
      std::vector<TPlanNodeExecSummary> ::const_iterator _iter36;
      for (_iter36 = this->nodes.begin(); _iter36 != this->nodes.end(); ++_iter36)
      {
        xfer += (*_iter36).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exch_to_sender_map) {
    xfer += oprot->writeFieldBegin("exch_to_sender_map", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->exch_to_sender_map.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter37;
      for (_iter37 = this->exch_to_sender_map.begin(); _iter37 != this->exch_to_sender_map.end(); ++_iter37)
      {
        xfer += oprot->writeI32(_iter37->first);
        xfer += oprot->writeI32(_iter37->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_logs) {
    xfer += oprot->writeFieldBegin("error_logs", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->error_logs.size()));
      std::vector<std::string> ::const_iterator _iter38;
      for (_iter38 = this->error_logs.begin(); _iter38 != this->error_logs.end(); ++_iter38)
      {
        xfer += oprot->writeString((*_iter38));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->progress.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecSummary &a, TExecSummary &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.status, b.status);
  swap(a.nodes, b.nodes);
  swap(a.exch_to_sender_map, b.exch_to_sender_map);
  swap(a.error_logs, b.error_logs);
  swap(a.progress, b.progress);
  swap(a.__isset, b.__isset);
}

TExecSummary::TExecSummary(const TExecSummary& other39) {
  state = other39.state;
  status = other39.status;
  nodes = other39.nodes;
  exch_to_sender_map = other39.exch_to_sender_map;
  error_logs = other39.error_logs;
  progress = other39.progress;
  __isset = other39.__isset;
}
TExecSummary& TExecSummary::operator=(const TExecSummary& other40) {
  state = other40.state;
  status = other40.status;
  nodes = other40.nodes;
  exch_to_sender_map = other40.exch_to_sender_map;
  error_logs = other40.error_logs;
  progress = other40.progress;
  __isset = other40.__isset;
  return *this;
}
void TExecSummary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecSummary(";
  out << "state=" << to_string(state);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "nodes="; (__isset.nodes ? (out << to_string(nodes)) : (out << "<null>"));
  out << ", " << "exch_to_sender_map="; (__isset.exch_to_sender_map ? (out << to_string(exch_to_sender_map)) : (out << "<null>"));
  out << ", " << "error_logs="; (__isset.error_logs ? (out << to_string(error_logs)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ")";
}

} // namespace
